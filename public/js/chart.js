// https://www.sitepoint.com/ajaxjquery-getjson-simple-example/

var current_channels = [];
// record chart_dict creation time
var block_period = 70; // 5 mins
var chart_dict = {};
var device_dict = {};
var sensor_id = null;
var block_array = []  // replaces json file
var t_avg = 300;
chart_data = {}
chart_data['timeline'] = [];

// object size function
Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};

// initialise
for(var i = 0; i < 10; i++) {
  chart_data[i.toString()] = []; 
  var size = Object.size(chart_data);
}

$(document).ready(function () {
    // json generated by /routes/charts.js
    $.getJSON('../json/test.json', function (json_data) {

        // itterate over json
        for (var i=0; i<json_data.length; i++) {

            // assign channel number
            sensor_id = json_data[i].channel;
            
            // register this sensor id if not already present
            if (!current_channels.includes(sensor_id)) {
                
                // t_start is key name for this chart data set
                // t_start = Math.floor(json_data[i]['start_time']);
                t_start = json_data[i]['start_time'];
                chart_dict[t_start] = {};
                
                // create averaging accumulator for new-found sensor
                device_dict[sensor_id] = {};
                ch_data = {'value': json_data[i]['watts'], 'count': 1, 'start_time': Math.floor(json_data[i]['epoch_time'] / t_avg) * t_avg};
                device_dict[sensor_id] = ch_data
                // Get the size of an object
                var len = Object.size(device_dict);
                // update channels log
                current_channels.push(json_data[i]['channel']);
            }
            // detect averaging time period elapsed
            // 
            if (parseInt(json_data[i]['epoch_time']) > parseInt(device_dict[sensor_id].start_time) + 300) {  // device_dict TIMEOUT
                // t_start is key name for next chart data set
                t_start = json_data[i]['epoch_time'];
                chart_dict[t_start] = {}

                var ch_avg = 0
                // Get the number of channels in device_dict
                // A new sensor might be added or removed at any time !!!
                var size = Object.size(device_dict);
                chnl = Object.keys(device_dict);

                // itterate over sensors present
                for (var ch=0; ch<size; ch++) {
                    // trap divide by zero - this problem may have gone away
                    if (device_dict[chnl[ch]]['count'] > 0) { 

                        // calculate this channel average
                        var ch_avg=parseInt(device_dict[chnl[ch]]['value']/device_dict[chnl[ch]]['count']);
                        chart_dict[t_start][chnl[ch]] = ch_avg;
                        chart_dict[t_start]['ts'] = t_start;
                    } else {
                        console.log('ch'+device_dict[chnl[ch]]['ch']+' divide by zero encountered');
                    } 
                } 
                // add this data set to data array
                block_array.push(chart_dict[t_start]);
                
                // averaged and stored reset this device dict 
                for (var ch=0; ch<device_dict[sensor_id].length; ch++) {
                    device_dict[sensor_id]['value'] = 0;
                    device_dict[sensor_id]['count'] = 0;
                    device_dict[sensor_id]['start_time'] = Math.floor(json_data[i]['epoch_time'] / t_avg) * t_avg;
                }
                
                // add the current row to newly emptied dict
                device_dict[sensor_id]['start_time'] = json_data[i]['epoch_time'];
                device_dict[sensor_id]['count'] = 1;
                device_dict[sensor_id]['value'] = json_data[i]['watts'];
            }
            // add this row data to the current dict
            device_dict[sensor_id].count = device_dict[sensor_id].count +1
            device_dict[sensor_id].value = device_dict[sensor_id].value +parseInt(json_data[i]['watts']);
        } 
//        console.log(JSON.stringify(block_array)); 

        var x_hour = Math.floor(block_array[0]['ts']/3600);

        for(var i=0; i<block_array.length;i++) {
            
        //    var ba = parseInt(block_array[i]['ts']);
            var ba = block_array[i]['ts'];
            
            if (Math.floor(ba/3600) > x_hour) {
                var dt = new Date(ba*1000);
                var hr = dt.getDate()+':'+dt.getHours();
                chart_data.timeline.push(hr);
                x_hour = Math.floor(ba/3600);

            } else {
                chart_data.timeline.push(' ');
            }
            
            // scan this data set
            for(var chn in block_array[i]) {
                // test for valid channel no.
                for(var j=0; j< 10; j++) {
                    if (parseInt(chn) === j) {
                        chart_data[chn].push( block_array[i][chn]);
                    }
                } 
            }
        }

        // produce the chart for /routes/charts.js
        var ctx = document.getElementById("myChart");
        var myChart = new Chart(ctx, {
            type: 'line',
            data: {
            labels: chart_data['timeline'],
                datasets: [
                { 
                    data: chart_data[0],
                    label: "ch0",
                    borderColor: "#3e95cd",
                    fill: false
                },
                {
                    data: chart_data[2],
                    label: "ch2",
                    borderColor: "#8e5ea2",
                    fill: false
                }
                ]
            },
            options: {
                tooltips: {
                    mode: 'label'
                },
                responsive: true,
                scales: {
                    xAxes: [{
                        stacked: true,
			            ticks: {
			                autoSkip: false
			            }
                    }],
                    yAxes: [{
                        stacked: true
                    }]
                }
            }  
        }); 
    });
});

